use bitvec::vec::BitVec;

use crate::ch347;

/// Clock 为一个时钟
#[derive(Clone, Copy)]
struct Clock {
    tms: bool,
    tdi: bool,
    capture: bool,
}

impl From<Clock> for u8 {
    fn from(value: Clock) -> Self {
        let Clock { tms, tdi, .. } = value;
        (u8::from(tms) << 1) | (u8::from(tdi) << 4)
    }
}

#[derive(Default)]
struct TapInfo {
    taps: Vec<u8>, // 记录的是 Tap 的 IR 长度
    ir_pre: usize, // 标识选择的Tap, IR命令前面需要填充的数量
    ir_pos: usize, // 后，填充 1, 那么其他就是 Bypass
    pre: usize,
    pos: usize,
}

struct Jtager {
    taparam: TapInfo,
    bits: BitVec,
    clocks: Vec<Clock>,
}

impl Jtager {
    pub fn new() -> Self {
        Self {
            taparam: Default::default(),
            bits: BitVec::new(),
            clocks: Vec::new(),
        }
    }

    fn shift_bits(&mut self, tms: bool, tdi: bool, capture: bool) {
        if self.clocks.len() > 127 {
            self.flush();
        }

        self.clocks.push(Clock { tms, tdi, capture });
    }

    fn flush(&mut self) {
        let mut buffer = [0; 130];
        let mut obuf = vec![];
        let mut command = vec![0xD2];

        for &i in self.clocks.iter() {
            let byte = u8::from(i);
            // the byte is clock low, bit 0 = 1 that clock high
            obuf.push(byte);
            obuf.push(byte | 0x01);
        }
        command.extend_from_slice(&(obuf.len() as u16).to_le_bytes());
        command.extend_from_slice(&obuf);

        ch347::write(&command).unwrap();
        ch347::read(&mut buffer).unwrap();

        for (&c, &byte) in self.clocks.iter().zip(&buffer[3..]) {
            let Clock { capture, .. } = c;
            if capture {
                self.bits.push(byte != 0x00);
            }
        }
    }

    fn read_capturd_bits(&mut self) -> Result<BitVec, String> {
        self.flush();
        Ok(std::mem::take(&mut self.bits))
    }

    // 必须要作为最开始调用的函数
    // 复位并进入Idle, 注意，我主要用于验证，这里不会记录状态机，主要保证每次Jtag操作回到Idle状态
    fn reset_idle(&mut self) {
        for i in [true, true, true, true, true, false] {
            self.shift_bits(i, true, false);
        }
    }

    // 从 Idle 进入 ShiftDR/ShiftIR
    fn enter_shift(&mut self, shiftdr: bool) {
        if !shiftir {
            self.shift_bits(true, true, false);
        }
    }

    // 扫描 IDCODES, 复位后， 进入DR扫描IDCODE
    fn idcode_scan(&mut self) -> Vec<u32> {
        let idcodes = Vec::new();
    }

    // 做初始化，并扫描 IDCODE 和 Taps
    pub fn init(&mut self) {
        self.reset_idle();
    }
}
